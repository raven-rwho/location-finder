{"version":3,"file":"serializr.min.js","sources":["../src/utils/utils.js","../src/api/getDefaultModelSchema.js","../src/api/setDefaultModelSchema.js","../src/api/createModelSchema.js","../src/types/primitive.js","../src/api/serializable.js","../src/core/serialize.js","../src/core/Context.js","../src/core/deserialize.js","../src/types/identifier.js","../src/types/object.js","../src/types/reference.js","../src/types/list.js","../src/constants.js","../src/api/createSimpleSchema.js","../src/core/update.js","../src/types/date.js","../src/types/alias.js","../src/types/custom.js","../src/types/map.js","../src/types/mapAsArray.js"],"sourcesContent":["export function GUARDED_NOOP(err) {\n    if (err) // unguarded error...\n        throw new Error(err)\n}\n\nexport function once(fn) {\n    var fired = false\n    return function() {\n        if (!fired) {\n            fired = true\n            return fn.apply(null, arguments)\n        }\n        invariant(false, \"callback was invoked twice\")\n    }\n}\n\nexport function invariant(cond, message) {\n    if (!cond)\n        throw new Error(\"[serializr] \" + (message || \"Illegal State\"))\n}\n\nexport function parallel(ar, processor, cb) {\n  // TODO: limit parallelization?\n    if (ar.length === 0)\n        return void cb(null, [])\n    var left = ar.length\n    var resultArray = []\n    var failed = false\n    var processorCb = function(idx, err, result) {\n        if (err) {\n            if (!failed) {\n                failed = true\n                cb(err)\n            }\n        } else {\n            resultArray[idx] = result\n            if (--left === 0)\n                cb(null, resultArray)\n        }\n    }\n    ar.forEach(function (value, idx) {\n        processor(value, processorCb.bind(null, idx))\n    })\n}\n\nexport function isPrimitive(value) {\n    if (value === null)\n        return true\n    return typeof value !== \"object\" && typeof value !== \"function\"\n}\n\nexport function isModelSchema(thing) {\n    return thing && thing.factory && thing.props\n}\n\nexport function isPropSchema(thing) {\n    return thing && thing.serializer && thing.deserializer\n}\n\nexport function isAliasedPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && !!propSchema.jsonname\n}\n\nexport function isIdentifierPropSchema(propSchema) {\n    return  typeof propSchema === \"object\" && propSchema.identifier === true\n}\n\nexport function isAssignableTo(actualType, expectedType) {\n    while (actualType) {\n        if (actualType === expectedType)\n            return true\n        actualType = actualType.extends\n    }\n    return false\n}\n\nexport function isMapLike(thing) {\n    return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\n}\n\nexport function getIdentifierProp(modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    // optimization: cache this lookup\n    while (modelSchema) {\n        for (var propName in modelSchema.props)\n            if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\n                return propName\n        modelSchema = modelSchema.extends\n    }\n    return null\n}\n","import { isModelSchema } from \"../utils/utils\"\n\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\nexport default function getDefaultModelSchema(thing) {\n    if (!thing)\n        return null\n    if (isModelSchema(thing))\n        return thing\n    if (isModelSchema(thing.serializeInfo))\n        return thing.serializeInfo\n    if (thing.constructor && thing.constructor.serializeInfo)\n        return thing.constructor.serializeInfo\n}\n","import { invariant, isModelSchema } from \"../utils/utils\"\n\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\nexport default function setDefaultModelSchema(clazz, modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    return clazz.serializeInfo = modelSchema\n}\n","import { invariant } from \"../utils/utils\"\nimport getDefaultModelSchema from \"./getDefaultModelSchema\"\nimport setDefaultModelSchema from \"./setDefaultModelSchema\"\n\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\nexport default function createModelSchema(clazz, props, factory) {\n    invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\")\n    invariant(typeof clazz === \"function\", \"expected constructor function\")\n    var model = {\n        targetClass: clazz,\n        factory: factory || function() {\n            return new clazz()\n        },\n        props: props\n    }\n  // find super model\n    if (clazz.prototype.constructor !== Object) {\n        var s = getDefaultModelSchema(clazz.prototype.constructor)\n        if (s && s.targetClass !== clazz)\n            model.extends = s\n    }\n    setDefaultModelSchema(clazz, model)\n    return model\n}\n","import { invariant } from \"../utils/utils\"\nimport { isPrimitive } from \"../utils/utils\"\n\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @returns {ModelSchema}\n */\nexport default function primitive() {\n    return {\n        serializer: function (value) {\n            invariant(isPrimitive(value), \"this value is not primitive: \" + value)\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            if (!isPrimitive(jsonValue))\n                return void done(\"[serializr] this value is not primitive: \" + jsonValue)\n            return void done(null, jsonValue)\n        }\n    }\n}\n","import { invariant, isPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport primitive from \"../types/primitive\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport createModelSchema from \"../api/createModelSchema\"\n\n// Ugly way to get the parameter names since they aren't easily retrievable via reflection\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg\nvar ARGUMENT_NAMES = /([^\\s,]+)/g\n\nfunction getParamNames(func) {\n    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\")\n    var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES)\n    if(result === null)\n        result = []\n    return result\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n    invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\")\n    // Fix for @serializable used in class constructor params (typescript)\n    var factory\n    if (propName === undefined && typeof target === \"function\"\n        && target.prototype\n        && descriptor !== undefined && typeof descriptor === \"number\") {\n        invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\")\n        invariant(propSchema.jsonname, \"Constructor params must use alias(name)\")\n        var paramNames = getParamNames(target)\n        if (paramNames.length >= descriptor) {\n            propName = paramNames[descriptor]\n            propSchema.paramNumber = descriptor\n            descriptor = undefined\n            target = target.prototype\n            // Create a factory so the constructor is called properly\n            factory = function(context) {\n                var params = []\n                for (var i = 0; i < target.constructor.length; i++) {\n                    Object.keys(context.modelSchema.props).forEach(function (key) {\n                        var prop = context.modelSchema.props[key]\n                        if (prop.paramNumber === i) {\n                            params[i] = context.json[prop.jsonname]\n                        }\n                    })\n                }\n\n                return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))\n            }\n        }\n    }\n    invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\")\n    var info = getDefaultModelSchema(target)\n\n    if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\n        info = createModelSchema(target.constructor, {}, factory)\n    if (info && info.targetClass !== target.constructor)\n        // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n        info = createModelSchema(target.constructor, {}, factory)\n    info.props[propName] = propSchema\n    // MWE: why won't babel work without?\n    if (descriptor && !descriptor.get && !descriptor.set)\n        descriptor.writable = true\n    return descriptor\n}\n\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\nexport default function serializable(arg1, arg2, arg3) {\n    if (arguments.length === 1) {\n        // decorated with propSchema\n        var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1\n        invariant(isPropSchema(propSchema), \"@serializable expects prop schema\")\n        return serializableDecorator.bind(null, propSchema)\n    } else {\n        // decorated without arguments, treat as primitive\n        return serializableDecorator(primitive(), arg1, arg2, arg3)\n    }\n}\n","import { invariant, isPrimitive } from \"../utils/utils\"\nimport createModelSchema from \"../api/createModelSchema\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport setDefaultModelSchema from \"../api/setDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\nexport default function serialize(arg1, arg2) {\n    invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\")\n    var thing = arguments.length === 1 ? arg1 : arg2\n    var schema = arguments.length === 1 ? null : arg1\n    if (Array.isArray(thing)) {\n        if (thing.length === 0)\n            return [] // don't bother finding a schema\n        else if (!schema)\n            schema = getDefaultModelSchema(thing[0])\n    } else if (!schema) {\n        schema = getDefaultModelSchema(thing)\n    }\n    invariant(!!schema, \"Failed to find default schema for \" + arg1)\n    if (Array.isArray(thing))\n        return thing.map(function (item) {\n            return serializeWithSchema(schema, item)\n        })\n    return serializeWithSchema(schema, thing)\n}\n\nexport function serializeWithSchema(schema, obj) {\n    invariant(schema && typeof schema === \"object\", \"Expected schema\")\n    invariant(obj && typeof obj === \"object\", \"Expected object\")\n    var res\n    if (schema.extends)\n        res = serializeWithSchema(schema.extends, obj)\n    else {\n        // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n        res = {}\n    }\n    Object.keys(schema.props).forEach(function (key) {\n        var propDef = schema.props[key]\n        if (key === \"*\") {\n            invariant(propDef === true, \"prop schema '*' can onle be used with 'true'\")\n            serializeStarProps(schema, obj, res)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonValue = propDef.serializer(obj[key], key, obj)\n        if (jsonValue === SKIP){\n            return\n        }\n        res[propDef.jsonname || key] = jsonValue\n    })\n    return res\n}\n\nexport function serializeStarProps(schema, obj, target) {\n    for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n        var value = obj[key]\n        // when serializing only serialize primitive props. Assumes other props (without schema) are local state that doesn't need serialization\n        if (isPrimitive(value))\n            target[key] = value\n    }\n}\n\n/**\n * The `serializeAll` decorator can be used on a class to signal that all primitive properties should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { a: 3, b: undefined, c: 5 });\n */\nexport function serializeAll(target) {\n    invariant(arguments.length === 1 && typeof target === \"function\", \"@serializeAll can only be used as class decorator\")\n\n    var info = getDefaultModelSchema(target)\n    if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n        info = createModelSchema(target, {})\n        setDefaultModelSchema(target, info)\n    }\n\n    getDefaultModelSchema(target).props[\"*\"] = true\n    return target\n}\n","import { GUARDED_NOOP, once, invariant, isAssignableTo } from \"../utils/utils\"\n\nexport default function Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n    this.parentContext = parentContext\n    this.isRoot = !parentContext\n    this.pendingCallbacks = 0\n    this.pendingRefsCount = 0\n    this.onReadyCb = onReadyCb || GUARDED_NOOP\n    this.json = json\n    this.target = null\n    this.hasError = false\n    this.modelSchema = modelSchema\n    if (this.isRoot) {\n        this.rootContext = this\n        this.args = customArgs\n        this.pendingRefs = {} // uuid: [{ modelSchema, uuid, cb }]\n        this.resolvedRefs = {} // uuid: [{ modelSchema, value }]\n    } else {\n        this.rootContext = parentContext.rootContext\n        this.args = parentContext.args\n    }\n}\n\nContext.prototype.createCallback = function (fn) {\n    this.pendingCallbacks++\n    // once: defend against user-land calling 'done' twice\n    return once(function(err, value) {\n        if (err) {\n            if (!this.hasError) {\n                this.hasError = true\n                this.onReadyCb(err)\n            }\n        } else if (!this.hasError) {\n            fn(value)\n            if (--this.pendingCallbacks === this.pendingRefsCount) {\n                if (this.pendingRefsCount > 0)\n                  // all pending callbacks are pending reference resolvers. not good.\n                    this.onReadyCb(new Error(\n                      \"Unresolvable references in json: \\\"\" +\n                      Object.keys(this.pendingRefs).filter(function (uuid) {\n                          return this.pendingRefs[uuid].length > 0\n                      }, this).join(\"\\\", \\\"\") +\n                       \"\\\"\"\n                  ))\n                else\n                  this.onReadyCb(null, this.target)\n            }\n        }\n    }.bind(this))\n}\n\n// given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\nContext.prototype.await = function (modelSchema, uuid, callback) {\n    invariant(this.isRoot)\n    if (uuid in this.resolvedRefs) {\n        var match = this.resolvedRefs[uuid].filter(function (resolved) {\n            return isAssignableTo(resolved.modelSchema, modelSchema)\n        })[0]\n        if (match)\n            return void callback(null, match.value)\n    }\n    this.pendingRefsCount++\n    if (!this.pendingRefs[uuid])\n        this.pendingRefs[uuid] = []\n    this.pendingRefs[uuid].push({\n        modelSchema: modelSchema,\n        uuid: uuid,\n        callback: callback\n    })\n}\n\n// given a model schema, uuid and value, resolve all references that where looking for this object\nContext.prototype.resolve = function(modelSchema, uuid, value) {\n    invariant(this.isRoot)\n    if (!this.resolvedRefs[uuid])\n        this.resolvedRefs[uuid] = []\n    this.resolvedRefs[uuid].push({\n        modelSchema: modelSchema, value: value\n    })\n    if (uuid in this.pendingRefs) {\n        for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n            var opts = this.pendingRefs[uuid][i]\n            if (isAssignableTo(modelSchema, opts.modelSchema)) {\n                this.pendingRefs[uuid].splice(i, 1)\n                this.pendingRefsCount--\n                opts.callback(null, value)\n            }\n        }\n    }\n}","/*\n * Deserialization\n */\nimport { invariant, isPrimitive, isModelSchema, parallel, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\nimport Context from \"./Context\"\n\nfunction schemaHasAlias(schema, name) {\n    for (var key in schema.props)\n        if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\n            return true\n    return false\n}\n\nfunction deserializeStarProps(schema, obj, json) {\n    for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n        var value = json[key]\n        // when deserializing we don't want to silently ignore 'unparseable data' to avoid confusing bugs\n        invariant(isPrimitive(value), \"encountered non primitive value while deserializing '*' properties in property '\" + key + \"': \" + value)\n        obj[key] = value\n    }\n}\n\n/**\n * Deserializes a json structor into an object graph.\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserializaiton has finished.\n * First argument is the optional error, second argument is the deserialized object (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nexport default function deserialize(schema, json, callback, customArgs) {\n    invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\")\n    schema = getDefaultModelSchema(schema)\n    invariant(isModelSchema(schema), \"first argument should be model schema\")\n    if (Array.isArray(json)) {\n        var items = []\n        parallel(\n            json,\n            function (childJson, itemDone) {\n                var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs)\n                // instance is created synchronously so can be pushed\n                items.push(instance)\n            },\n            callback || GUARDED_NOOP\n        )\n        return items\n    } else\n  return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\n}\n\nexport function deserializeObjectWithSchema(parentContext, schema, json, callback, customArgs) {\n    if (json === null || json === undefined)\n        return void callback(null, null)\n    var context = new Context(parentContext, schema, json, callback, customArgs)\n    var target = schema.factory(context)\n    // todo async invariant\n    invariant(!!target, \"No object returned from factory\")\n    // TODO: make invariant?            invariant(schema.extends || !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n    context.target = target\n    var lock = context.createCallback(GUARDED_NOOP)\n    deserializePropsWithSchema(context, schema, json, target)\n    lock()\n    return target\n}\n\nexport function deserializePropsWithSchema(context, schema, json, target) {\n    if (schema.extends)\n        deserializePropsWithSchema(context, schema.extends, json, target)\n    Object.keys(schema.props).forEach(function (propName) {\n        var propDef = schema.props[propName]\n        if (propName === \"*\") {\n            invariant(propDef === true, \"prop schema '*' can onle be used with 'true'\")\n            deserializeStarProps(schema, target, json)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonAttr = propDef.jsonname || propName\n        if (!(jsonAttr in json))\n            return\n        propDef.deserializer(\n            json[jsonAttr],\n            // for individual props, use root context based callbacks\n            // this allows props to complete after completing the object itself\n            // enabling reference resolving and such\n            context.rootContext.createCallback(function (value) {\n                if (value !== SKIP){\n                    target[propName] = value\n                }\n            }),\n            context,\n            target[propName] // initial value\n        )\n    })\n}\n","import { invariant } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\nfunction defaultRegisterFunction(id, value, context) {\n    context.rootContext.resolve(context.modelSchema, id, context.target)\n}\n\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n * \n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n * \n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n * \n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param {RegisterFunction} registerFn optional function to register this object during creation.\n *\n * @returns {PropSchema}\n */\nexport default function identifier(registerFn) {\n    invariant(!registerFn || typeof registerFn === \"function\", \"First argument should be omitted or function\")\n    return {\n        identifier: true,\n        serializer: _defaultPrimitiveProp.serializer,\n        deserializer: function (jsonValue, done, context) {\n            _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\n                defaultRegisterFunction(id, context.target, context)\n                if (registerFn)\n                    registerFn(id, context.target, context)\n                done(err, id)\n            })\n        }\n    }\n}","import { invariant, isModelSchema } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport serialize from \"../core/serialize\"\nimport { deserializeObjectWithSchema } from \"../core/deserialize\"\n\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @returns {PropSchema}\n */\nexport default function object(modelSchema) {\n    invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    return {\n        serializer: function (item) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (item === null || item === undefined)\n                return item\n            return serialize(modelSchema, item)\n        },\n        deserializer: function (childJson, done, context) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (childJson === null || childJson === undefined)\n                return void done(null, childJson)\n            return void deserializeObjectWithSchema(context, modelSchema, childJson, done)\n        }\n    }\n}\n","import { invariant, isModelSchema, getIdentifierProp } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\n\nfunction createDefaultRefLookup(modelSchema) {\n    return function resolve(uuid, cb, context) {\n        context.rootContext.await(modelSchema, uuid, cb)\n    }\n}\n\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction} lookupFn function\n * @returns {PropSchema}\n */\nexport default function reference(target, lookupFn) {\n    invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    var initialized = false\n    var childIdentifierAttribute\n    function initialize() {\n        initialized = true\n        invariant(typeof target !== \"string\" || lookupFn, \"if the reference target is specified by attribute name, a lookup function is required\")\n        invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function\")\n        if (typeof target === \"string\")\n            childIdentifierAttribute = target\n        else {\n            var modelSchema = getDefaultModelSchema(target)\n            invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema)\n            lookupFn = lookupFn || createDefaultRefLookup(modelSchema)\n            childIdentifierAttribute = getIdentifierProp(modelSchema)\n            invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\")\n        }\n    }\n    return {\n        serializer: function (item) {\n            if (!initialized)\n                initialize()\n            return item ? item[childIdentifierAttribute] : null\n        },\n        deserializer: function(identifierValue, done, context) {\n            if (!initialized)\n                initialize()\n            if (identifierValue === null || identifierValue === undefined)\n                done(null, identifierValue)\n            else\n                lookupFn(identifierValue, done, context)\n        }\n    }\n}\n","import { invariant, isPropSchema, isAliasedPropSchema, parallel } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @returns {PropSchema}\n */\nexport default function list(propSchema) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n    return {\n        serializer: function (ar) {\n            invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\")\n            return ar.map(propSchema.serializer)\n        },\n        deserializer: function(jsonArray, done, context) {\n            if (!Array.isArray(jsonArray))\n                return void done(\"[serializr] expected JSON array\")\n            parallel(\n                jsonArray,\n                function (item, itemDone) {\n                    return propSchema.deserializer(item, itemDone, context)\n                },\n                done\n            )\n        }\n    }\n}\n","import primitive from \"./types/primitive\"\n\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\nexport var SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true }\n\nexport var _defaultPrimitiveProp = primitive()\n","/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nexport default function createSimpleSchema(props) {\n    return {\n        factory: function() {\n            return {}\n        },\n        props: props\n    }\n}\n","/*\n * Update\n */\n\nimport { invariant, isModelSchema, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport Context from \"./Context\"\nimport { deserializePropsWithSchema } from \"./deserialize\"\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n */\nexport default function update(modelSchema, target, json, callback, customArgs) {\n    var inferModelSchema =\n        arguments.length === 2 // only target and json\n        || typeof arguments[2] === \"function\" // callback as third arg\n\n    if (inferModelSchema) {\n        target = arguments[0]\n        modelSchema = getDefaultModelSchema(target)\n        json = arguments[1]\n        callback = arguments[2]\n        customArgs = arguments[3]\n    } else {\n        modelSchema = getDefaultModelSchema(modelSchema)\n    }\n    invariant(isModelSchema(modelSchema), \"update failed to determine schema\")\n    invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\")\n    var context = new Context(null, modelSchema, json, callback, customArgs)\n    context.target = target\n    var lock = context.createCallback(GUARDED_NOOP)\n    deserializePropsWithSchema(context, modelSchema, json, target)\n    lock()\n}\n","import { invariant } from \"../utils/utils\"\n\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @returns\n */\nexport default function date() {\n  // TODO: add format option?\n    return {\n        serializer: function(value) {\n            if (value === null || value === undefined)\n                return value\n            invariant(value instanceof Date, \"Expected Date object\")\n            return value.getTime()\n        },\n        deserializer: function (jsonValue, done) {\n            if (jsonValue === null || jsonValue === undefined)\n                return void done(null, jsonValue)\n            return void done(null, new Date(jsonValue))\n        }\n    }\n}\n","import { invariant, isPropSchema, isAliasedPropSchema, isIdentifierPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nexport default function alias(name, propSchema) {\n    invariant(name && typeof name === \"string\", \"expected prop name as first argument\")\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\")\n    return {\n        jsonname: name,\n        serializer: propSchema.serializer,\n        deserializer: propSchema.deserializer,\n        identifier: isIdentifierPropSchema(propSchema)\n    }\n}\n","import { invariant } from \"../utils/utils\"\n\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the signature:\n * `(value, context) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(s, { a: 6 }), { a: 4 });\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @returns {PropSchema}\n */\nexport default function custom(serializer, deserializer) {\n    invariant(typeof serializer === \"function\", \"first argument should be function\")\n    invariant(typeof deserializer === \"function\", \"second argument should be function\")\n    return {\n        serializer: serializer,\n        deserializer: function (jsonValue, done, context, oldValue) {\n            done(null, deserializer(jsonValue, context, oldValue))\n        }\n    }\n}\n","import { invariant, isAliasedPropSchema, isPropSchema, isMapLike } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport list from \"./list\"\n\n/**\n* Similar to list, but map represents a string keyed dynamic collection.\n* This can be both plain objects (default) or ES6 Map like structures.\n* This will be inferred from the initial value of the targetted attribute.\n*\n* @param {*} propSchema\n* @returns\n*/\nexport default function map(propSchema) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n    return {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\n            var isMap = isMapLike(m)\n            var result = {}\n            if (isMap)\n                m.forEach(function(value, key) {\n                    result[key] = propSchema.serializer(value)\n                })\n            else for (var key in m)\n                result[key] = propSchema.serializer(m[key])\n            return result\n        },\n        deserializer: function(jsonObject, done, context, oldValue) {\n            if (!jsonObject || typeof jsonObject !== \"object\")\n                return void done(\"[serializr] expected JSON object\")\n            var keys = Object.keys(jsonObject)\n            list(propSchema).deserializer(\n              keys.map(function (key) {\n                  return jsonObject[key]\n              }),\n              function (err, values) {\n                  if (err)\n                      return void done(err)\n                  var isMap = isMapLike(oldValue)\n                  var newValue\n                  if (isMap) {\n                      // if the oldValue is a map, we recycle it\n                      // there are many variations and this way we don't have to\n                      // know about the original constructor\n                      oldValue.clear()\n                      newValue = oldValue\n                  } else\n                      newValue = {}\n                  for (var i = 0, l = keys.length; i < l; i++)\n                      if (isMap)\n                          newValue.set(keys[i], values[i])\n                      else\n                          newValue[keys[i]] = values[i]\n                  done(null, newValue)\n              },\n              context\n          )\n        }\n    }\n}\n","import { invariant, isPropSchema, isMapLike } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport list from \"./list\"\n\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is contained in the 'value object'.\n * Example: consider Map<id: number, customer: Customer> where the Customer object has the id stored on itself.\n * mapAsArray stores all values from the map into an array which is serialized.\n * Deserialization returns a ES6 Map or plain object object where the `keyPropertyName` of each object is used for keys.\n * For ES6 maps this has the benefit of being allowed to have non-string keys in the map. The serialized json also may be slightly more compact.\n *\n * @param {any} propSchema, {string} keyPropertyName - the property of stored objects used as key in the map\n * @returns\n */\nexport default function mapAsArray(propSchema, keyPropertyName) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!!keyPropertyName, \"expected key property name as second argument\")\n    return {\n        serializer: function (m) {\n            var result = []\n            // eslint-disable-next-line no-unused-vars\n            m.forEach(function (value, key) {\n                result.push(propSchema.serializer(value))\n            })\n            return result\n        },\n        deserializer: function (jsonArray, done, context, oldValue) {\n            list(propSchema).deserializer(\n              jsonArray,\n              function (err, values) {\n                  if (err)\n                      return void done(err)\n                  var isMap = isMapLike(oldValue)\n                  var newValue\n                  if (isMap) {\n                      oldValue.clear()\n                      newValue = oldValue\n                  } else\n                      newValue = {}\n                  for (var i = 0, l = jsonArray.length; i < l; i++)\n                      if (isMap)\n                          newValue.set(values[i][keyPropertyName], values[i])\n                      else\n                          newValue[values[i][keyPropertyName].toString()] = values[i]\n                  done(null, newValue)\n              },\n              context\n          )\n        }\n    }\n}\n"],"names":["GUARDED_NOOP","err","Error","once","fn","fired","apply","arguments","invariant","cond","message","parallel","ar","processor","cb","length","left","resultArray","failed","processorCb","idx","result","forEach","value","bind","isPrimitive","isModelSchema","thing","factory","props","isPropSchema","serializer","deserializer","isAliasedPropSchema","propSchema","jsonname","isIdentifierPropSchema","identifier","isAssignableTo","actualType","expectedType","extends","isMapLike","keys","clear","getIdentifierProp","modelSchema","propName","getDefaultModelSchema","serializeInfo","constructor","setDefaultModelSchema","clazz","createModelSchema","Object","model","targetClass","prototype","s","primitive","jsonValue","done","getParamNames","func","fnStr","toString","replace","STRIP_COMMENTS","slice","indexOf","match","ARGUMENT_NAMES","serializableDecorator","target","descriptor","undefined","paramNames","paramNumber","context","params","i","key","prop","json","Function","concat","info","hasOwnProperty","get","set","writable","serialize","arg1","arg2","schema","Array","isArray","map","item","serializeWithSchema","obj","res","propDef","serializeStarProps","_defaultPrimitiveProp","SKIP","Context","parentContext","onReadyCb","customArgs","this","isRoot","pendingCallbacks","pendingRefsCount","hasError","rootContext","args","pendingRefs","resolvedRefs","schemaHasAlias","name","deserializeStarProps","deserializeObjectWithSchema","callback","lock","createCallback","deserializePropsWithSchema","jsonAttr","defaultRegisterFunction","id","resolve","object","childJson","createDefaultRefLookup","uuid","await","reference","lookupFn","initialize","initialized","childIdentifierAttribute","identifierValue","list","jsonArray","itemDone","Symbol","filter","join","resolved","push","opts","splice","arg3","items","instance","registerFn","Date","getTime","oldValue","m","jsonObject","values","newValue","isMap","l","keyPropertyName"],"mappings":"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"}